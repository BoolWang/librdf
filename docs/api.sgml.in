<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V3.1//EN"[]> <!-- -*- DocBook -*- -->
<book id="redlandAPI">
  <?dbhtml filename='index.html'>
  <bookinfo>
    <date>2004-05-06</date>
    <title>Redland RDF Application Framework API Reference Manual</title>
    <authorgroup>
      <author>
	<firstname>Dave</firstname>
	<surname>Beckett</surname>
	<affiliation>
          <orgname>University of Bristol</orgname>
	  <orgdiv>Institute for Learning and Research Technology (ILRT)</orgdiv>
	  <address>
	    <email>Dave.Beckett@bristol.ac.uk</email>
	  </address>
	</affiliation>
      </author>
    </authorgroup>
    <copyright>
      <year>2000-2004</year>
      <holder>Dave Beckett, University of Bristol, UK</holder>
      <indexterm>
	<primary>
          <author>
	    <firstname>Dave</firstname>
	    <surname>Beckett</surname>
	    <affiliation>
	      <orgname>University of Bristol</orgname>
	      <orgdiv>Institute for Learning and Research Technology (ILRT)</orgdiv>
	    </affiliation>
	  </author>
         </primary>
      </indexterm>
    </copyright>
    <legalnotice>
      <para>
      Permission is granted to copy, distribute and/or modify this document
      under the same licensing terms as Redland.
     </para>
    </legalnotice>

    <pubdate role="CVS">$Date$</pubdate>

    <abstract>
      <title>Abstract</title>
      <para>
This document describes the APIs provided by
<ulink url="http://www.librdf.org/">Redland</ulink> to use the RDF
model; manipulate statements, resources, predicates and objects in the model;
parse RDF/XML syntax, query and store the models.
      </para>
<para>
See also the <ulink url="http://www.librdf.org/">Redland Home Page</ulink>
and the <ulink url="../README.html">main document overview</ulink>.
</para>

    </abstract>

   </bookinfo>

<toc></toc>

<chapter id="objects">
<?dbhtml filename='objects.html'>
<title>Introduction to Objects in C</title>
<para>
Redland uses objects and is written in C, which has no built in support for
object construction, destruction, copying etc.  This library thus uses
conventions for the names of the routines providing the
constructor, destructor and copy constructor functionality for a class as
well as conventions for the general methods.
</para>
<para>
A class FOO is defined as a C typedef <literal>librdf_foo</literal>,
and its a public interface defined in <filename>rdf_foo.h</filename>
along with any public or private types, enumerations or constants.
The private definitions are not exposed to library users, only
internally when the library is built.  The implementation of the
class is defined in file <filename>rdf_foo.c</filename> and may
include private (static) functions either for internal
implementations or to satisfy part of a factory API.
</para>
<para>Each class may have a class initialiser / termination pair
of functions which must be called before any object in the class is created,
and after the last object has been freed. These are defined with signatures
like:
<programlisting>
  void init_librdf_foo (...)
  void terminate_librdf_foo (void)
</programlisting>
The arguments to the initialisation vary since there are sometimes
some class wide options that can be set at initialisation time.
</para>
<para>
The object constructor(s) are defined with signatures like:
<programlisting>
  librdf_foo* librdf_new_foo(void)
</programlisting>
which takes no parameters.  Additional constructors can be defined
with parameters, and are named in a similar way with an extra part
appropriate for the name for example:
<programlisting>
  librdf_foo* librdf_new_foo_with_options(char *options)
</programlisting>
</para>
<para>A copy constructor may be defined which will have the signature:
<programlisting>
  librdf_foo* librdf_new_foo_from_foo(librdf_foo* old_foo)
</programlisting>
</para>
<para>A destructor must be defined and has the signature:
<programlisting>
  void librdf_free_foo(librdf_foo* foo)
</programlisting>
</para>
<para>Methods of the class have names starting with <literal>librdf_foo_</literal> and
examples could be:
<programlisting>
  /* accessor functions to object part 'thing' */
  int librdf_foo_set_thing(librdf_foo* foo, char *thing)
  char *librdf_foo_get_thing(librdf_foo* foo)
</programlisting>
</para>
<para>It is often convienent to get a string representation of an
object for further processing, debugging or serialisation.  There are
two conventions for methods that provide this functionality - the
first is when a pointer is returned to a <emphasis>shared</emphasis>
copy of the string and in that case the method ends
<literal>_as_string</literal>.  The second is when a pointer is
returned to a <emphasis>newly allocated</emphasis> string in which
case the method ends <literal>_to_string</literal>.</para>
</chapter>

<chapter id="world">
<?dbhtml filename='world.html'>
<title>RDF World</title>
<para>
This module initialises the Redland library and references all resources
from it.  The world object is the single global variable in Redland
that all the classes, their factories and implementations reference.
</para>

<para>
In most programs there should be only one Redland world, using multiple
models although multiple worlds are possible.
</para>

<sect1>
<title>RDF World Class</title>
@INCLUDE init.sgml
</sect1>
</chapter>

<chapter id="model">
<?dbhtml filename='model.html'>
<title>RDF Model</title>
<para>
This module provides the RDF model support which is a bag of statements
(duplicates are allowed).  Models can have statements added and removed,
be queries and stored which is implemented by the storage classes.
</para>

<sect1>
<title>RDF Model Class</title>
@INCLUDE model.sgml
</sect1>
</chapter>

<chapter id="statement">
<?dbhtml filename='statement.html'>
<title>RDF Statement / Assertion / Triple</title>
<para>
This module provides the RDF statement functionality, and contains
three parts: resource, predicate and object which are all
nodes provided by the librdf_node class.  Statements can be added /
removed from models.
</para>
<para>
Statements have at least one rdf:type and are always of rdf:type rdf:resource.
They can be present in the model and/or
<emphasis>reified</emphasis> in which they are quoted or talked about
by other statements.
</para>
<sect1>
<title>RDF Statement Class</title>
@INCLUDE statement.sgml
</sect1>
</chapter>

<chapter id="node">
<?dbhtml filename='node.html'>
<title>RDF Resource / Predicate / Literal</title>
<para>
This module provides the elements of the RDF statement - resource (or subject o source), predicate (or property or arc) and object (or target): resource / literal.  These make up parts of the statement object.
</para>

<para>
Nodes have two types - resource (used for subject, predicate and
object) and literal (only used for object).  Resources have URIs,
Literals have string content plus optional XML Language
and a flag if the content is XML which is used for
supporting XML Literals.
</para>
<sect1>
<title>RDF Node Class</title>
@INCLUDE node.sgml
</sect1>
</chapter>

<chapter id="parser">
<?dbhtml filename='parser.html'>
<title>RDF Parsers</title>
<para>
These modules parse RDF/XML syntax and construct models, maybe via
streams of statements.  At present Redland does not have a built in
RDF/XML parser and can be used without one.
</para>
<sect1>
<title>RDF Parser Class</title>
@INCLUDE parser.sgml
</sect1>
</chapter>

<chapter id="concepts">
<?dbhtml filename='concepts.html'>
<title>Schema Concepts</title>
<para>
This class provides Redland librdf_uri* and librdf_node* references
for concepts in the RDF and RDFS schemas, for use in user code
without prior assignment, via macros such as LIBRDF_MS_type_URI for
the librdf_uri* or LIBRDF_MS_type for the librdf_node*.  They should
be copied if used.
</para>

<para>
Two separate concepts that can be additionally used are
LIBRDF_URI_RDF_MS and LIBRDF_URI_RDF_SCHEMA which are librdf_uri*
for the namespace names.
</para>
</chapter>


<chapter id="digest">
<?dbhtml filename='digest.html'>
<title>Content Digests</title>
<para>
This module provides digests, which are algorithms that operate over
arrays of octets / bytes producing a cryptographically strong digest
that can be used to represent the content.  Digests functions have
different levels of strength.  Digests can be used to generating keys
for hashes and identifiers based on content.
</para>
<sect1>
<title>Digest Class</title>
@INCLUDE digest.sgml
</sect1>
</chapter>

<chapter id="hash">
<?dbhtml filename='hash.html'>
<title>Hashes</title>
<para>
A hash in this library is a bag of key/value pairs (with duplicates allowed)
indexed and manipulated by the key.  The hashes can be stored in
memory or with persistant storage.
</para>
<sect1>
<title>Hash Class</title>
@INCLUDE hash.sgml
</sect1>
</chapter>

<chapter id="query">
<?dbhtml filename='query.html'>
<title>RDF Query</title>
<para>
This module provides query language support for RDF models
either via an adaptor class or direct by persistant storage.
</para>
<sect1>
<title>RDF Query Class</title>
@INCLUDE query.sgml
</sect1>
</chapter>

<chapter id="query_results">
<?dbhtml filename='query_results.html'>
<title>RDF QueryResults</title>
<para>
This module provides an abstraction for query results that
can be in the form of variable bindings or a librdf_stream of
librdf_statement objects.
</para>
<sect1>
<title>RDF QueryResults Class</title>
@INCLUDE query_results.sgml
</sect1>
</chapter>

<chapter id="serializer">
<?dbhtml filename='serializer.html'>
<title>RDF Serializer</title>
<para>
This module provides RDF graph to syntax serialization support
via factory classes providing one or more particular target syntaxes.
</para>
<sect1>
<title>RDF Serializer Class</title>
@INCLUDE serializer.sgml
</sect1>
</chapter>

<chapter id="storage">
<?dbhtml filename='storage.html'>
<title>RDF Model Storage</title>
<para>
This module provides storage for RDF models either in memory or
persistant storage.
</para>
<sect1>
<title>RDF Model Storage Class</title>
@INCLUDE storage.sgml
</sect1>
</chapter>

<chapter id="stream">
<?dbhtml filename='stream.html'>
<title>Streams - Sequences of Statements</title>
<para>
This module provides a method to generate a stream of statements,
suitable for outputing from RDF/XML parsers, returning as the
results of queries and serialising models in order to manipulate
them or transform into another syntax.
</para>
<sect1>
<title>RDF Statement Stream Class</title>
@INCLUDE stream.sgml
</sect1>
</chapter>

<chapter id="iterator">
<?dbhtml filename='iterator.html'>
<title>Data Iterators</title>
<para>
The iterator provides a generic way to receive a sequence of values
(order may or may not be import) from objects, usually generated
on demand.
</para>
<sect1>
<title>Iterator Class</title>
@INCLUDE iterator.sgml
</sect1>
</chapter>

<chapter id="uri">
<?dbhtml filename='uri.html'>
<title>URIs</title>
<para>
This class provides very simple URI functionality - mostly just storage
and comparison.
</para>
<sect1>
<title>URI Class</title>
@INCLUDE uri.sgml
</sect1>
</chapter>


<chapter id="utf8">
<?dbhtml filename='utf8.html'>
<title>UTF-8</title>
<para>
This utility class provides some functions for UTF-8 to/from ISO Latin-1
de/encoding.
</para>
<sect1>
<title>UTF8 Class</title>
@INCLUDE utf8.sgml
</sect1>
</chapter>


<chapter id="heuristics">
<?dbhtml filename='heuristics.html'>
<title>Heuristics</title>
<para>
This module provides utility functions that cross other modules and classes.
</para>
<sect1>
<title>Heuristic functions</title>
@INCLUDE heuristics.sgml
</sect1>
</chapter>


</book>
