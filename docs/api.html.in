<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <title>Redland RDF Application Framework - API Reference Manual</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>

<h1 style="text-align:center">Redland RDF Application Framework - API
Reference Manual</h1>


<p>Copyright 2000-2004 <a href="http://purl.org/net/dajobe/">Dave Beckett</a>, <a href="http://www.ilrt.bris.ac.uk/">Institute for Learning and Research Technology</a>, <a href="http://www.bristol.ac.uk/">University of Bristol</a></p>

<h2>Introduction</h2>

<p>This document describes the APIs provided by
<a href="http://librdf.org/">Redland</a> to use the RDF
model; manipulate statements, resources, predicates and objects in the model;
parse RDF/XML syntax, query and store the models.</p>

<p>See also the <a href="http://www.librdf.org/">Redland Home Page</a>
and the <a href="../README.html">main document overview</a>.
</p>

<h2>Introduction to Objects in C</h2>

<p>
Redland uses objects and is written in C, which has no built in support for
object construction, destruction, copying etc.  This library thus uses
conventions for the names of the routines providing the
constructor, destructor and copy constructor functionality for a class as
well as conventions for the general methods.
</p>

<p>
A class FOO is defined as a C typedef <code>librdf_foo</code>,
and its a public interface defined in <code>rdf_foo.h</code>
along with any public or private types, enumerations or constants.
The private definitions are not exposed to library users, only
internally when the library is built.  The implementation of the
class is defined in file <code>rdf_foo.c</code> and may
include private (static) functions either for internal
implementations or to satisfy part of a factory API.
</p>
<p>Each class may have a class initialiser / termination pair
of functions which must be called before any object in the class is created,
and after the last object has been freed. These are defined with signatures
like:
<pre>
  void init_librdf_foo (...)
  void terminate_librdf_foo (void)
</pre>
The arguments to the initialisation vary since there are sometimes
some class wide options that can be set at initialisation time.
</p>
<p>
The object constructor(s) are defined with signatures like:
<pre>
  librdf_foo* librdf_new_foo(void)
</pre>
which takes no parameters.  Additional constructors can be defined
with parameters, and are named in a similar way with an extra part
appropriate for the name for example:
<pre>
  librdf_foo* librdf_new_foo_with_options(char *options)
</pre>
</p>
<p>A copy constructor may be defined which will have the signature:
<pre>
  librdf_foo* librdf_new_foo_from_foo(librdf_foo* old_foo)
</pre>
</p>
<p>A destructor must be defined and has the signature:
<pre>
  void librdf_free_foo(librdf_foo* foo)
</pre>
</p>
<p>Methods of the class have names starting with <code>librdf_foo_</code> and
examples could be:
<pre>
  /* accessor functions to object part 'thing' */
  int librdf_foo_set_thing(librdf_foo* foo, char *thing)
  char *librdf_foo_get_thing(librdf_foo* foo)
</pre>
</p>
<p>It is often convienent to get a string representation of an
object for further processing, debugging or serialisation.  There are
two conventions for methods that provide this functionality - the
first is when a pointer is returned to a <em>shared</em>
copy of the string and in that case the method ends
<code>_as_string</code>.  The second is when a pointer is
returned to a <em>newly allocated</em> string in which
case the method ends <code>_to_string</code>.</p>


<h2>RDF World</h2>
<p>
This module initialises the Redland library and reference all resources
from it.
</p>

<h2>RDF World Class</h2>
@INCLUDE api_init.html

<h2>RDF Model</h2>
<p>
This module provides the RDF model support which is a bag of statements
(duplicates are allowed).  Models can have statements added and removed,
be queries and stored which is implemented by the storage classes.
</p>

<h2>RDF Model Class</h2>
@INCLUDE api_model.html

<h2>RDF Statement / Assertion / Triple</h2>
<p>
This module provides the RDF statement functionality, and contains
three parts: resource, predicate and object which are all
nodes provided by the librdf_node class.  Statements can be added /
removed from models.
</p>
<p>
Statements have at least one rdf:type and are always of rdf:type rdf:resource.
They can be present in the model and/or
<em>reified</em> in which they are quoted or talked about
by other statements.
</p>

<h2>RDF Statement Class</h2>
@INCLUDE api_statement.html



<h2>RDF Resource / Predicate / Literal</h2>
<p>
This module provides the elements of the RDF statement - resource (or subject o source), predicate (or property or arc) and object (or target): resource / literal.  These make up parts of the statement object.
</p>

<p>
Nodes have two types - resource (used for subject, predicate and
object) and literal (only used for object).  Resources have URIs,
Literals have string content plus optional XML Language
and a flag if the content is XML which is used for
supporting XML Literals.
</p>

<h2>RDF Node Class</h2>
@INCLUDE api_node.html



<h2>RDF Parsers</h2>
<p>
These modules parse RDF/XML syntax and construct models, maybe via
streams of statements.  At present Redland does not have a built in
RDF/XML parser and can be used without one.
</p>

<h2>RDF Parser Class</h2>
@INCLUDE api_parser.html


<h2>Raptor RDF Parser Implementation Class</h2>
@INCLUDE api_parser_raptor.html



<h2>Content Digests</h2>
<p>
This module provides digests, which are algorithms that operate over
arrays of octets / bytes producing a cryptographically strong digest
that can be used to represent the content.  Digests functions have
different levels of strength.  Digests can be used to generating keys
for hashes and identifiers based on content.
</p>

<h2>Digest Class</h2>
@INCLUDE api_digest.html


<h2>OpenSSL Digests Implementation</h2>
@INCLUDE api_digest_openssl.html


<h2>Local MD5 Digest Implementation</h2>
@INCLUDE api_digest_md5.html



<h2>Hashes</h2>
<p>
A hash in this library is a bag of key/value pairs (with duplicates allowed)
indexed and manipulated by the key.  The hashes can be stored in
memory or with persistant storage.
</p>

<h2>Hash Class</h2>
@INCLUDE api_hash.html


<h2>Hash Cursor Implementation Class</h2>
@INCLUDE api_hash_cursor.html

<h2>Berkeley DB Hash Implementation Class</h2>
@INCLUDE api_hash_bdb.html


<h2>In Memory Hash Implementation Class</h2>
@INCLUDE api_hash_memory.html



<h2>RDF Query</h2>
<p>
This module provides query language support for RDF models
either via an adaptor class or direct by persistant storage.
</p>

<h2>RDF Query Class</h2>
@INCLUDE api_query.html


<h2>RDF Query Triples Class</h2>
@INCLUDE api_query_triples.html



<h2>RDF Serializer</h2>
<p>
This module provides RDF graph to syntax serialization support
via factory classes providing one or more particular target syntaxes.
</p>

<h2>RDF Serializer Class</h2>
@INCLUDE api_serializer.html


<h2>RDF Serializer Raptor Class</h2>
@INCLUDE api_serializer_raptor.html



<h2>RDF Model Storage</h2>
<p>
This module provides storage for RDF models either in memory or
persistant storage.
</p>

<h2>RDF Model Storage Class</h2>
@INCLUDE api_storage.html


<h2>In Memory List RDF Model Storage Implementation Class</h2>
@INCLUDE api_storage_list.html


<h2>Multiple Hashes RDF Model Storage Implementation Class</h2>
@INCLUDE api_storage_hashes.html

<h2>MySQL RDF Model Storage Implementation Class</h2>
@INCLUDE api_storage_mysql.html

<h2>3store RDF Model Storage Implementation Class</h2>
@INCLUDE api_storage_tstore.html



<h2>RDF Model Serialisation</h2>
<p>
This module provides a method to generate a stream of statements,
suitable for outputing from RDF/XML parsers, returning as the
results of queries and serialising models in order to manipulate
them or transform into another syntax.
</p>

<h2>RDF Statement Stream Class</h2>
@INCLUDE api_stream.html



<h2>Data Iterators</h2>
<p>
The iterator provides a generic way to receive a sequence of values
(order may or may not be import) from objects, usually generated
on demand.
</p>

<h2>Iterator Class</h2>
@INCLUDE api_iterator.html



<h2>Lists</h2>
<p>
The list module provides a simple in-memory list.
</p>

<h2>List Class</h2>
<p>
This class is implemented as a stack, new items are added to the front
of the list.
</p>
@INCLUDE api_list.html



<h2>URIs</h2>
<p>
This class provides very simple URI functionality - mostly just storage
and comparison.
</p>

<h2>URI Class</h2>
@INCLUDE api_uri.html




<h2>UTF-8</h2>
<p>
This utility class provides some functions for UTF-8 to/from ISO Latin-1
de/encoding.
</p>

<h2>UTF8 Class</h2>
@INCLUDE api_utf8.html




<h2>Heuristics</h2>
<p>
This module provides utility functions that cross other modules and classes.
</p>

<h2>Heuristic functions</h2>
@INCLUDE api_heuristics.html




</body>
</html>
