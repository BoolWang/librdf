<HTML>
<HEAD>
<TITLE>librdf - API</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000085">


<H1 ALIGN="CENTER">librdf API</H1>

<H1 ALIGN="CENTER"><A HREF="http://www.ilrt.bristol.ac.uk/people/cmdjb/">Dave Beckett</A></H1>

<H2>1. Introduction</H2>

<P>The parts that I currently want to be pluggable include:
<UL>
  <LI>XML parsers - via pipe/filter, expat, xerces-c?, ...
  <LI>RDF parsers - via pipe/filter, libwww rdf, mozilla,  ...
  <LI>Storage models - in memory, [gn]dbm files, triples-in-SQL, ...
  <LI>Query languages
  <LI>(Utility classes for Hashes, Digests)
</UL>

<P>The architecture is tricky to write in text but I'll have a go.
These are the concepts/classes: 

<PRE>
   Node - a node/arc in an RDF graph
     Contains either a URI OR String + XML language

   Statement - or triple
     Contains three Nodes resource, property and object as well as a
     reference to an assertion context.

   Model
     Contains: 
        A bag/set of Statements OR a list of sub-Models
        A reference to 'Storage'

   'Storage'
     Implements a Statement storage API and at least one Statement query API(s)

   'RDF Parser' ('RDF DataSource'? 'RDF Reader'?) + 'RDF Parser Factory'
     Asserts Statements to a given model OR uses a given XML Parser
     and model.

   'XML Parser' + 'XML Parser Factory'
     Provides a standard XML API (DOM?, SAX?)

   'RDF Syntax generator' ('RDF DataSink', 'RDF Consumer?)
     Emits formatted RDF in XML, other syntaxes, encodings - SOAP?

   Missing concepts/ stuff I know about but will do after V1.0:
     Namespaces - I've no support for these
     Unicode - I've assumed C char*=UTF-8 string
     Typing and Classes - to support:
     RDF Schemas (I've had an offer from someone else to work on this)
</PRE>


<P>
I'm working out more of my librdf Application Framework design as
previously mentioned: <A HREF="http://lists.w3.org/Archives/Public/www-rdf-interest/2000Jun/0082.html">http://lists.w3.org/Archives/Public/www-rdf-interest/2000Jun/0082.html</A>

<PRE>
model / storage / parsing / streaming architecture:


Base Classes:
  class Statement - triples (resource, property, object)

  class Model - a set of Statements with a link to a Storage ...
    many methods, most passed on to Storage

  class Storage - knows how to store/retrieve Statements using identifiers
    lots of methods such as:
    method add_statement (in Statement, out identifier, ...)
      - returns a storage specific identifier (URI) that can be used
        to get the statement later
    method remove_statement (in identifier, ...)
    method get_statements (out stream of Statements)
    method find (in Node subject, in Node predicate, in Node object, out stream of Statements)
    method find (in Node subject, in Node predicate, in Node object, in/out Model)
    ...
 
Then we add:
  class XML DOM Parser - builds an in-memory DOM representation
    constructor (...)
    method init(in XML content)
    method get_dom (out in-memory DOM representation)

  class XML SAX Parser - generates SAX-like events
    constructor (...)
    method init(in stream of XML content)
    method register_sax_event_1 (in function) 
    ...
    method register_sax_event_&lt;n&gt; (in function) 

  class RDF Parser
    constructor (...)
    method parse_xml_events(in/out model, in XML SAX Parser)
    method parse_xml_tree(in/out model, in XML DOM Parser)


so you can do things like this:

   storage = new Storage (use Berkeley DB V2 please, ...)
   model = new Model (storage)
   rdf = new RDF Parser(...)
   www = new URI Resolver (XML content URI)

   if (using DOM model) {
     /* everything constructed in memory - better be small */
     xml_dom = new XML DOM Parser(...)
     xml_dom-&gt;init(www-&gt;get_as_string)
     rdf-&gt;parse_xml_tree(model, xml_dom)
     delete xml_dom
   } else if (using SAX-like event model) {
     xml_sax = new XML SAX Parser(...)
     xml_sax-&gt;init(www-&gt;get_as_stream)
     rdf-&gt;parse_xml_events(model, xml_sax)
     delete xml_sax
   } else if (using standalone RDF parser) {
     ... more thought needed here ...
     rdf_stream = new Stream ("command for standalone parser to emit triples")
     rdfutil.add_statements_to_model_from_stream_of_triples(model, rdf_stream)
   }
   delete www

   ... do stuff with model ...

</PRE>


<P>Implemented so far:
<UL>
  <LI>Hash (and Hash Factory) - GDBM, BDB V2, in memory
  <LI>Digest (and Digest Factory) - MD5, SHA, RIPEMD160
  <LI>Node
  <LI>Statement
  <LI>Model (just API)
</UL>


<H2>2. XML Parser Factory Class</H2>

<P>A factory that returns <EM>XML Parser</EM> objects that implement
the interface.

<P>Implementations:
<UL>
<LI>via pipe/filter to external program
<LI>expat
<LI>...
</UL>


<H2>3. XML Parser</H2>
<P>An object that implements the XML interface

<H2>4. RDF Parser Factory</H2>

<P>Implementations:
<UL>
<LI>via pipe/filter to external program
<LI>libwww version
<LI>...
</UL>

<H2>5. RDF Parser</H2>

<H2>6. <TT>rdf_digest_factory</TT> - Digest Factory</H2>

<P>Implementations:
<UL>
<LI><TT>rdf_digest_openssl</TT>(*) - The OpenSSL digests - MD5, SHA1, RIPEMD160
<LI>portable version of MD5(*)
<LI>portable version of SHA1(*)
<LI>portable version of RIPEMD160(*)
</UL>

<H2>7. <TT>rdf_digest</TT> Digest(*)</H2>

<P>A digesting function is a mathematical function operating on a
series of octets/bytes returning a digest (sequence of octets) that
represents it with defined levels of confidence over how unique this
is

<P>Obtained by asking the digest factory for a digest type.

<H2>8. <TT>rdf_hash_factory</TT> - Hash Factory</H2>


<P>Implementations:
<UL>
<LI><TT>rdf_hash_gdbm</TT> - GDBM(*)
<LI>Berkeley DB v2
<LI>In Memory(*)
<LI>...
</UL>

<H2>9. <TT>rdf_hash</TT> - Hash(*)</H2>

<P>A mapping of keys to values, also known as an associative array.

<P>Obtained by asking the hash factory for a hash type.


<H2>10. <TT>rdf_node</TT> - Node(*) (for Resource / Literals)</H2>

<P>Contains either a URI (for resources) OR String + XML language (for literals).

<P>Ignored things: Unicode encoding issues UTF-8, XML Namespaces


<H2>11. Statement</H2>

<P>A statement consists of a resource, property and object all of
which are <TT>rdf_node</TT> objects.  An object can be either a
resource node or a literal node.  Statements also a list of assertion
contexts which are used to manage when the same statement is asserted
multiple times in different models.

<H3>11.1. Issues</H3>

<P><B>issue</B> maybe this should be managed by a statement factory
to prevent problems over allocation issues.

<P><B>issue</B> If two agents assert the same 'statement' (aka p/s/o
triple) into an RDF datastore, do we model that as:
<OL>
<LI>a single statement
with two 'asserting contexts' associated with it
<LI>as two statements having the same content.
</OL>

<P>Former - says Dan

<P><B>issue</B> The math language we used makes it seem wrong to attempt to have
the same statement appear in S twice; however pragmatics of real
world apps means we'll want two of _something_ to be stored.

<P><B>issue</B> what is an asserting context?

<P><B>Dan:</B> More than a count - we want to be able to
retract everything from 
<A HREF="http://rdfwebring.org/ldab/rdfweb/webwho.xrdf">http://rdfwebring.org/ldab/rdfweb/webwho.xrdf</A>
and replace it with what we get from it on a later visit. So there's
likely all sorts of things we'll want to track. I don't believe it's
RDF's core business to specify these -- different apps will store
different things. Over time some common cases will emerge; right now,
we don't have enough experience to know how be

<P>Maybe the context would be a URI refered to by a util:gotFrom relation.
e.g. If it was got-from an HTTP transaction there's a whole bundle of
information (date, time, auth, content-neg prefs etc)

<H2>12. Model</H2>

A model (or DataSource) contains:<BR>
<UL>
<LI>A bag/set of Statements OR a list of sub-Models
<LI>A reference to a 'Storage'
</UL>

<P>The list of sub models is there to allow layering Models for such
things as adding transactions, filtering, ... (more thought needed)

<H2>13. 'Storage Model'</H2>

<H2>20. Other Issues</H2>

<UL>
<LI>1. Need to model all RDFS defined classes in order to implement M&amp;S?<BR>
<P>Do you need need to model all the M&S concepts in order to support
schemas?  e.g. what if I want to query for all resources with an
rdf:_23 property but have implemented a bag as a hash.  Each content
of the bag contains a property rdf:_1 to rdf:_30 which have to be
accessible in the graph if people ask for them.  If not, then the
model has been changed.

<LI>2. Can you actually infer the number 14 from rdf:_14

<LI>3. Can bag/seq members have 'numbers' rdf:_14 from non-RDF namespace?

<LI>4. automatic renumbering of bags - is this allowed?

<P><B>Dan pronounced:</B> "the semantics behind the assignment of
numbered container-membership properties (ie. rdf:_n) to members of
RDF containers (Seq, Alt, Bag) is application specific. Generic RDF
processors should make no assumptions about continuity of these
numbered properties (eg. rdf_1, rdf_2, rdf_34223 is a reasonable
sequence). While some RDF application contexts may support or employ
automatic renumbering of these container properties, other
applications are likely to employ 'gappy' sequences of numbered
container membership properties (eg. to maintain a correlation with
another sequence elsewhere, such as street numbers). RDF processors
should not make closed-world assumptions about container membership
(ie. a description of a Bag/Seq/Alt might well provide only a partial
unumeration of its members). RDF processors can make use of
additional information provided in RDF to understand more accuraately
the semantics associated with particular uses of the basic RDF
container constructs."

<LI>5. track namespaces of URIs for use on output?

<LI>6. do we need an isReified AND an isAsserted flag or just one (per statement)?

<LI>7. do we need isReified and/or isAsserted booleans in statements

<LI>8.  is it so important to be able to ask classing questions
sub/superclass that have lots of depths, that the typing support
should be delivered with the framework?

</UL>

<HR>
<SMALL>
<PRE>
$Id$
</PRE>
</SMALL>

</BODY>
</HTML>
